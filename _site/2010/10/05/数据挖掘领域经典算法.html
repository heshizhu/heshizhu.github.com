<!DOCTYPE html>
<html>

<head>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <title>Alex He - 数据挖掘领域经典算法</title>
 <meta name="author" content="Alex He" />
 <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" media="screen" charset="utf-8"/>
 <link rel="stylesheet" href="/stylesheets/vibrant_ink.css" type="text/css" media="screen" charset="utf-8"/>
 <script src="/javascripts/jquery.js" type="text/javascript" charset="utf-8"></script>
 <script src="/javascripts/jquery.github.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>

  <div id="site">
    <div id="header">      
      <h1>发现过程之美</h1>
      <div id="menu">        
        <a href="http://www.zhulin.org.cn">Alex He的博客</a>      
        <a href="/archives.html" id="blog_link">档案</a>      
        <a href="/about_me.html" id="about_me">关于我</a>
      </div>
    </div>  
    <div class = "clearfix"/>

    <div id="content">
      <div class="posts">
  <div class="post">
    <h1>数据挖掘领域经典算法</h1>
    <div class="date">2010年10月05日</div> 
    <div class="body">
      <p>偶见网页<a href="http://www.sciencenet.cn/m/user_content.aspx?id=302846">数据挖掘领域十大经典算法</a>，心血来潮，在学习的同时也想验验有哪些知道哪些实现过。</p>

<p>2006年12月，国际权威的学术组织the IEEE International Conference on Data Mining (ICDM)评选了数据挖掘领域的十大经典算法。那就让我们来看看参加评选的<a href="http://www.cs.uvm.edu/~icdm/algorithms/CandidateList.shtml">18个候选算法</a>。</p>

<p>1). <strong>C4.5</strong> C4.5就是一个决策树算法，它是决策树(决策树也就是做决策的节点间的组织方式像一棵树，其实是一个倒树)核心算法ID3的改进算法，所以基本上了解了一半决策树构造方法就能构造它。决策树构造方法其实就是每次选择一个好的特征以及分裂点作为当前节点的分类条件。C4.5比ID3改进的地方是：</p>

<ul>
<li>ID3选择属性用的是子树的信息增益(这里可以用很多方法来定义信息，ID3使用的是熵(entropy)(熵是一种不纯度度量准则)),也就是熵的变化值.而C4.5用的是信息增益率。也就是多了个率嘛。一般来说率就是用来取平衡用的，就像方差起的作用差不多，比如有两个跑步的人，一个起点是10m/s的人、其1s后为20m/s；另一个人起速是1m/s、其1s后为2m/s。如果紧紧算差值那么两个差距就很大了，如果使用速度增加率(加速度)来衡量，2个人就是一样了。在这里，其克服了用信息增益选择属性时偏向选择取值多的属性的不足。</li>

<li>在树构造过程中进行剪枝，我在构造决策树的时候好讨厌那些挂着几个元素的节点。对于这种节点，干脆不考虑最好，不然很容易导致overfitting。</li>

<li>对非离散数据都能处理，这个其实就是一个个式，看对于连续型的值在哪里分裂好。也就是把连续性的数据转化为离散的值进行处理。</li>

<li>能够对不完整数据进行处理，这个重要也重要，其实也没那么重要，缺失数据采用一些方法补上去就是了。</li>
</ul>
<!--more-->
<p>2). <strong>CART</strong> CART也是一种决策树算法！相对于上着有条件实现一个节点下面有多个子树的多元分类，CART只是分类两个子树，这样实现起来稍稍简便些。所以说CART算法生成的决策树是结构简洁的二叉树。</p>

<p>3). <strong>KNN(K Nearest Neighbours)</strong> 这个很简单，就是看你周围的K个人(样本)那个类别的人占的多，那个多那我也是那个多的。实现起来就是对每个训练样本都计算与其相似度，选择相似度Top-K个训练样本出来，看这K个样本中那个类别的多些，谁多跟谁。</p>

<p>4). <strong>Naïve Bayes(朴素贝叶斯NB)</strong> NB认为各个特征是独立的，谁也不关谁的事。所以一个样本(特征值的集合，比如”数据结构”出现2词，“文件”出现1词)，可以通过对其所有出现特征在给定类别的概率相乘。比如“数据结构”出现在类1的概率为0.5，“文件”出现在类1的概率为0.3，则可认为其属于类1的概率为0.5<em>0.5</em>0.3。</p>

<p>5). <strong>Support Vector Machine(支持向量机SVM)</strong> SVM就是想找一个分类得最”好”的分类线/分类面(最近的一些两类样本到这个”线”的距离最远)。这个没具体实现过，上次听课，那位老师自称自己实现了SVM，敬佩其钻研精神。常用的工具包是LibSVM,SVMLight,MySVM.</p>

<p>6). <strong>EM(期望最大化)</strong> 这个我认为就是假设数据时由几个高斯分布组成的，所以最后就是要求几个高斯分布的参数。通过先假设几个值，然后通过反复迭代，以期望得到最好的拟合。</p>

<p>7). <strong>Apriori</strong> 这个是做关联规则用的。不知道为什么，一提高关联规则我就想到购物篮数据。这个没实现过，不过也还要理解，它就是通过支持度和置信度两个量来工作，不过对于Apriori，它通过频繁项集的一些规律(频繁项集的子集必定是频繁项集等等啦)来减少计算复杂度。</p>

<p>8). <strong>FP-Tree(Mining frequent patterns without candidate generation)</strong> 这个也不太清楚。FP-growth算法(Frequent Pattern-growth)使用了一种紧缩的数据结构来存储查找频繁项集所需要的全部信息。采用算法：将提供频繁项集的数据库压缩到一棵FP-tree来保留项集关联信息，然后将压缩后的数据库分成一组条件数据库（一种特殊类型的投影数据库），每个条件数据库关联一个频繁项集。</p>

<p>9). <strong>PageRank</strong> 大名鼎鼎的PageRank大家应该都知道(Google靠此专利发家，其实也不能说发家啦!)。对于这个算法我的理解就是：如果我指向你(网页间的连接)则表示我承认你，则在计算你的重要性的时候可以加上我的一部分重要性(到底多少，要看我自己有多少和我共承认多少个人)。通过反复这样来，可以求的一个稳定的衡量各个人(网页)重要性的值。不过这里必须要做些限制(一个人的开始默认重要性都是1)，不然那些值会越来越大越来越大。</p>

<p>10). <strong>HITS</strong> HITS也是一个连接分析算法，它是由IBM首先提出的。在HITS，每个节点(网页)都有一个重要度和权威度(Hubs and authorities)。通过反复通过权威度来求重要度，通过重要度来求权威度得到最后的权威度和重要度。</p>

<p>11). <strong>K-Means</strong> K-Means是一种最经典也是使用最广泛的聚类方法，时至今日任然有很多基于其的改进模型提出。K-Means的思想很简单，对于一个聚类任务(你需要指明聚成几个类，当然按照自然想法来说不应该需要指明类数，这个问题也是当前聚类任务的一个值得研究的课题)，首先随机选择K个簇中心，然后反复计算下面的过程直到所有簇中心不改变(簇集合不改变)为止：</p>

<ul>
<li>步骤1：对于每个对象，计算其与每个簇中心的相似度，把其归入与其最相似的那个簇中。</li>

<li>步骤2：更新簇中心，新的簇中心通过计算所有属于该簇的对象的平均值得到。 k-means 算法的工作过程说明如下：首先从n个数据对象任意选择 k 个对象作为初始聚类中心；而对于所剩下其它对象，则根据它们与这些聚类中心的相似度（距离），分别将它们分配给与其最相似的（聚类中心所代表的）聚类；然后再计算每个所获新聚类的聚类中心（该聚类中所有对象的均值）；不断重复这一过程直到标准测度函数开始收敛为止。一般都采用均方差作为标准测度函数. k个聚类具有以下特点：各聚类本身尽可能的紧凑，而各聚类之间尽可能的分开。</li>
</ul>

<p>12). <strong>BIRCH</strong> BIRCH也是一种聚类算法，其全称是Balanced Iterative Reducing and Clustering using Hierarchies。BIRCH也是只是看了理论没具体实现过。是一个综合的层次聚类特征(Clustering Feature, CF)和聚类特征树(CF Tree)两个概念，用于概括聚类描述。聚类特征树概括了聚类的有用信息，并且占用空间较元数据集合小得多，可以存放在内存中，从而可以提高算法在大型数据集合上的聚类速度及可伸缩性。 BIRCH算法包括以下两个阶段：</p>

<ul>
<li>扫描数据库，建立动态的一棵存放在内存的CF Tree。如果内存不够，则增大阈值，在原树基础上构造一棵较小的树。</li>

<li>对叶节点进一步利用一个全局性的聚类算法，改进聚类质量。 由于CF Tree的叶节点代表的聚类可能不是自然的聚类结果，原因是给定的阈值限制了簇的大小，并且数据的输入顺序也会影响到聚类结果。因此需要对叶节点进一步利用一个全局性的聚类算法，改进聚类质量。</li>
</ul>

<p>13). <strong>AdaBoost</strong> AdaBoost做分类的一般知道，它是一种boosting方法。这个不能说是一种算法，应该是一种方法，因为它可以建立在任何一种分类算法上，可以是决策树，NB，SVM等。 Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。使用adaboost分类器可以排除一些不必要的训练数据，并将关键放在关键的训练数据上面。</p>

<p>14). <strong>GSP</strong> GSP，全称为Generalized Sequential Pattern(广义序贯模式)，是一种序列挖掘算法。对于序列挖掘没有仔细看过，应该是基于关联规则的吧！网上是这样说的： GSP类似于Apriori算法，采用冗余候选模式的剪除策略和特殊的数据结构—–哈希树来实现候选模式的快速访存。 GSP算法描述:</p>

<ul>
<li>扫描序列数据库，得到长度为1的序列模式L1，作为初始的种子集。</li>

<li>根据长度为i 的种子集Li ，通过连接操作和修剪操作生成长度为i+1的候选序列模式Ci+1；然后扫描序列数据库，计算每个候选序列模式的支持度，产生长度为i+1的序列模式Li+1，并将Li+1作为新的种子集。</li>

<li>重复第二步，直到没有新的序列模式或新的候选序列模式产生为止。 产生候选序列模式主要分两步：</li>

<li>连接阶段：如果去掉序列模式s1的第一个项目与去掉序列模式s2的最后一个项目所得到的序列相同，则可以将s1与s2进行连接，即将s2的最后一个项目添加到s1中。</li>

<li>修切阶段：若某候选序列模式的某个子序列不是序列模式，则此候选序列模式不可能是序列模式，将它从候选序列模式中删除。 候选序列模式的支持度计算：对于给定的候选序列模式集合C，扫描序列数据库，对于其中的每一条序列s,找出集合C中被s所包含的所有候选序列模式，并增加其支持度计数。</li>
</ul>

<p>15). <strong>PrefixSpan</strong> 又是一个类似Apriori的序列挖掘算法，这个不了解。</p>

<p>16). <strong>CBA</strong> CBA(classification based on association)是基于关联规则发现方法的分类算法。该算法分两个步骤构造分类器。</p>

<ul>
<li>第一步：发现所有形如xi1∧x =&gt; Ci 的关联规则，即右部为类别属性值的类别关联规则(classification association rules，CAR)。</li>

<li>第二步：从已发现的CAR中选择高优先度的规则来覆盖训练集，也就是说，如果有多条关联规则的左部相同，而右部为不同的类，则选择具有最高置信度的规则作为可能规则。</li>
</ul>

<p>17). <strong>Finding reduct</strong> 18). <strong>gSpan</strong> 这两位都不了解。其中Finding reduct是粗糙集约减算法，gSpan是图挖掘算法。</p>

<p>当然最后夺得前十名头衔的分别是：<strong>C4.5</strong>，<strong>K-Means</strong>，<strong>SVM</strong>，<strong>Apriori</strong>，<strong>EM</strong>，<strong>PageRank</strong>，<strong>AdaBoost</strong>，<strong>KNN</strong>，<strong>NB</strong>和<strong>CART</strong>。</p>
    </div>
  </div>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'zhulin'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
    <!--<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'zhulin'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
  </script>-->

    </div>

    <hr/>
    <div id="footer">
      <div id="footer-inner">
        <div id="footer-content">
          <p>
            <a href="/contact.html">联系方式</a> | zhulin.org.cn 2014
          </p>
        </div>
      </div>
    </div>    
  </div>

</body>

</html>